<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Avoid Screen Flicker When Dark Mode Is On | vespaiach.com</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet" />
    <link
      href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet" />
    <link rel="stylesheet" href="main.css" />
    <script src="microlight.js" defer></script>
    <script defer>
      document.addEventListener('DOMContentLoaded', (event) => {
      debugger
        microlight.reset('language-js');
      });
    </script>
  </head>

  <body>
    <div class="w-full max-w-2xl p-5 mx-auto pt-4">
      <div>
        <a href="/" class="text-blue-500">← HOME</a>
      </div>

      <article class="prose prose-neutral prose-lg prose-headings:font-serif mb-12">
        <h2 class="font-bold mb-1 mt-12">Avoid Screen Flicker When Dark Mode Is On</h2>
        <p class="mb-12">July 01, 2022</p>
        <h2>Screen flicker</h2>
<p>Here was what my website looked like before (I used NextJS and Static Generation features to build my website).</p>
<p><img src="https://www.vespaiach.com/images/vespaiach_flashing.gif" alt="vespaiach.com"></p>
<p>If you look at the <code>&lt;html&gt;</code> tag, you will see its class attribute change after page refreshing. That was because I instructed the web page to read dark-mode preference from local storage and updated the class attribute accordingly after browsers had rendered the page. So, the flow of updating theme site was:</p>
<ol>
<li>Server returned HTML pages which were pre-rendered in light-mode</li>
<li>HTML pages read dark-mode preference from localstorage</li>
<li>Update <code>&lt;html&gt;</code> class attribute with correct theme mode (dark/ light)</li>
</ol>
<p>Obviously, in this flow, pages were displayed in light-mode at first, and jumped to dark-mode later, and that was what the flicker happened.</p>
<h2>How to prevent the screen flicker</h2>
<p>What if we send servers the dark-mode preference beforehand and let servers pre-render HTML with correct mode before sending it back to browsers? To achieve that, I decided to store dark-mode preference in cookies and because cookies were enclosed to requests to the server, servers would receive that information at runtime.</p>
<p>Well, that fixed the problem, but brought me another issue. My website was just HTML pages, so I leveraged the Static Generation features of NextJS to generate my websites at build time and didn’t use Server Rendering features to pre-render websites at server runtime. So servers receiving dark-mode reference cookies at runtime were meaningless!</p>
<p>To fix it, I instructed NextJS to generate HTML pages for both light-mode and dark-mode at build time and used the dark-mode preference cookies as a router to HTML pages with correct theme modes. So the flow of updating theme site became:</p>
<ol>
<li>Server built HTML pages for both light-mode and dark-mode at build time</li>
<li>Browser sent requests with dark-mode cookies enclosed</li>
<li>Server read dark-mode cookies and decided which HTML pages would be returned</li>
<li>Browser got correct theme mode versions of HTML pages</li>
</ol>
<h2>How to implement them in NextJS</h2>
<p>To instruct NextJS to pre-render HTML for light-mode and dark-mode in build time, I returned double paths of a HTML page in the <code>getStaticPaths</code> function. For instance:</p>
<pre><code class="language-js">// let say, I have an article with name path: &#39;article-name&#39;
export async function getStaticPaths() {
    return {
        paths: [
            { params: { name: &#39;article-name----light-mode&#39; } },
            { params: { name: &#39;article-name----dark-mode&#39; } },
        ],
        fallback: true,
    };
}
</code></pre>
<p>NextJS has a file-system based router, that means it generates website URLs based on how we create and name files/folders. So What I was doing here was to order NextJS to generate two HTML pages with two different URLs (one for light-mode/ another for dark-mode). Clearly, this wasn’t what I wanted, because now I got back two different URLs. So to deal with that, I created a middleware to read the requesting URL plus dark-mode preference cookies, then rewrote the request to the correct HTML page. For instance, a request URL <code>/posts/article-one</code> with dark-mode cookie on was rewritten to <code>/post/article-one----dark-mode</code></p>
<pre><code class="language-js">export function middleware(request: NextRequest) {
    const mode = .....; // read request&#39;s cookies for the mode
    if (request.nextUrl.pathname === &#39;/posts/article-one&#39;) {
        return NextResponse.rewrite(new URL(`/posts/article-one----${mode}`, request.url));
    }
}
</code></pre>
<p>These are two important steps that help my idea work. For more detail on how to implement it on my website, please check out the source code from <a href="https://github.com/vespaiach/personal_website">this link</a>.</p>

      </article>

      <div class="flex justify-end my-11">
        <a href="https://github.com/vespaiach/personal_website/blob/main/docs/hydration-failed-react-encoder-error.md" class="text-xs font-semibold text-secondary no-underline">GITHUB →</a>
      </div>
    </div>
  </body>
</html>
